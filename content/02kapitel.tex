%!TEX root = ../dokumentation.tex

\chapter{Algorithmen die das Rucksackproblem lösen}
Algorithmen, die das Rucksackproblem lösen können in zwei Kategorien 
eingeteilt werden: Algorithmen, die immer die Optimale Lösung finden, 
dafür aber eine inakzeptable Zeitkomplexität haben, 
oder Algorithmen mit geringerer Zeitkomplexitätsklasse, die 
aber nicht für eine Optimale Lösung garantieren.

\section{Brute-Force Algorithmus}
Um den Brute-Force-Algorithmus mathematisch zu beschreiben, 
müssen zuerst die Eingabeparameters des Problems beachtet werden. Sei 
$N$ die Gesamtanzahl der verfügbaren Gegenstände. Jeder 
Gegenstand $i$ hat einen bestimmten Wert $v_i$ und ein Gewicht $wi$. 
Der Rucksack hat eine maximale Kapazität $W$.

Der Algorithmus lässt sich nun in fünf Schritten beschreiben:

\texttt{Schritt 1}
Zunächst werden alle möglichen Teilmengen der Liste berechnet. 
Dies bedeutet, dass jede Kombination von Elementen gebildet 
wird, was insgesamt $2^n$ mögliche Teilmengen ergibt, wobei $n$ 
die Anzahl der Elemente in der Liste ist.

\texttt{Schritt 2:}
Für jede Teilmenge wird die Summe der Gewichte berechnet. 
Es wird überprüft, ob die Summe das Gewichtslimit nicht 
überschreitet. Wenn die Summe das Gewichtslimit nicht 
überschreitet, wird die Teilmenge als gültige Lösung 
betrachtet. Andernfalls wird sie verworfen.

\texttt{Schritt 3:}
Schritt 2 wird für jede Teilmenge wiederholt, bis eine 
Teilmenge gefunden wird, deren Gewicht das Gewichtslimit 
nicht erhöht.

\texttt{Schritt 4:}
Die Werte der gültigen Teilmenge(n), die die Bedingung in 
Schritt 3 erfüllen, werden summiert.

\texttt{Schritt 5:}
Schließlich wird der höchste Wert aus den gültigen 
Teilmengen als Antwort auf das Problem ausgewählt.\ \cite[vgl.]{balogun2022explanatory}

Die Laufzeitkomplexität des Brute-Force-Algorithmus beträgt 
$O(N2^N)$, da der Algorithmus alle möglichen Kombinationen der 
Gegenstände durchläuft. Diese exponentielle Komplexität 
macht den Brute-Force-Algorithmus für große $N$ unpraktikabel.\ \cite[vlg.]{hristakeva2005different}

\section{Branch-Bound Algorithmus}
Zuerst wird die Entscheidungsvariable $x_i$ für jeden 
Gegenstand $i$ definiert. Wenn Gegenstand $i$ ausgewählt wird, ist $x_i$ 
gleich $1$, andernfalls ist $x_i$ gleich $0$. Darüber hinaus 
verwenden wird die Funktion $f(x)$ zur Berechnung des 
Gesamtwerts einer Teilmenge von Gegenständen $x$ und die 
Funktion $g(x)$ zur Berechnung des Gesamtgewichts einer 
Teilmenge von Gegenständen $x$ verwendet.

Der Branch-and-Bound-Algorithmus beginnt mit einer 
Anfangslösung, die keinen Gegenstand enthält 
$(x = {0, 0, \cdots, 0})$. Anschließend wird ein Suchbaum 
aufgebaut, der alle möglichen Teilräume des Lösungsraums 
repräsentiert. Jeder Knoten im Suchbaum entspricht einer 
Teilmenge von Gegenständen. Der Algorithmus durchläuft den 
Suchbaum rekursiv, indem er Teilräume basierend auf 
Schätzungen und Grenzwerten erzeugt und abschneidet.

Die Schätzungsfunktion $E(xs)$ wird verwendet, um eine obere 
Schranke für den Wert einer Teilmenge von Gegenständen x zu 
berechnen. Diese Schätzung basiert auf einer Relaxation des 
Rucksackproblems, bei der angenommen wird, dass beliebige 
Bruchteile von Gegenständen ausgewählt werden können. Eine 
mögliche Schätzungsfunktion ist:

\begin{equation}
    E(x) = f(x) + (W - g(x)) \cdot \left(\frac{v_{i+1}}{w_{i+1}}\right)
\end{equation}

wobei $i$ der Index des nächsten Gegenstands ist, der nicht 
in $x$ enthalten ist. Diese Schätzung beruht auf der Annahme, 
dass der nächste Gegenstand mit dem höchsten Verhältnis von 
Wert zu Gewicht ausgewählt wird, um die verbleibende 
Kapazität optimal auszunutzen.

Basierend auf der Schätzungsfunktion wird ein Grenzwert 
(bound) für den aktuellen Teilraum berechnet. Der Grenzwert 
$B(x)$ wird definiert als der maximale Wert, der in einem 
Teilraum von Gegenständen x erreicht werden kann, ohne das 
Gewichtslimit zu überschreiten und wird 
rekursiv berechnet, indem alle Teilräume des aktuellen 
Teilraums betrachtet werden. Wenn ein Teilraum das 
Gewichtslimit überschreitet, wird der Grenzwert auf den Wert 
des aktuellen Teilraums gesetzt. Andernfalls wird der 
Grenzwert als die maximale Summe der Werte aller Gegenstände 
im Teilraum plus der maximalen Summe der Werte, die aus dem 
Rest des Rucksacks ausgewählt werden können, berechnet.

Der Branch-and-Bound-Algorithmus verwendet eine Tiefensuche, 
um den Suchbaum zu durchlaufen. Bei jedem Schritt wird ein 
Knoten ausgewählt und seine Kinderknoten generiert. Die 
Kinderknoten entsprechen den Teilräumen, die durch 
Hinzufügen oder Nicht-Hinzufügen des nächsten Gegenstands 
entstehen. Die Kinderknoten werden nach ihrem Grenzwert 
sortiert, und nur die vielversprechendsten Knoten werden 
weiter erkundet, während unproduktive Knoten abgeschnitten 
werden.

Der Algorithmus terminiert, wenn alle Knoten des Suchbaums 
erkundet wurden. Die optimale Lösung ist der Knoten mit dem 
höchsten Gesamtwert. Der Branch-and-Bound-Algorithmus 
gewährleistet die Rückgabe einer optimalen Lösung, da er 
systematisch den Suchraum durchsucht und unproduktive 
Teilräume abschneidet.

Die Laufzeit des 
Branch-and-Bound-Algorithmus hängt stark von der Größe des 
Suchraums ab. In einigen Fällen kann der Algorithmus 
sehr zeitaufwändig sein, insbesondere wenn die Anzahl der 
Gegenstände groß ist.\ \cite[vgl.]{Martello1987}

\section{Greedy-Algorithmus}
Der Greedy-Algorithmus zur Lösung des Rucksackproblems besteht 
aus fünf Schritten:

Schritt 1: Berechne das Verhältnis von Wert zu Gewicht für 
jeden Gegenstand.
Verhältnis \[r_i = \frac{v_i}{w_i}\]

Schritt 2: Sortiere die Gegenstände absteigend nach ihrem 
Verhältnis von Wert zu Gewicht.
\[r_1 \geq r_2 \geq \cdots \geq r_n\]

Schritt 3: Initialisiere den Rucksack und den Gesamtwert.
\[   \text{rucksack} = \{\}; \\
    \text{wert} = 0 \]
Schritt 4: Durchlaufe die sortierte Liste der Gegenstände.\\
Für $i = 1$ bis $n$: 
Wenn das Hinzufügen des Gegenstands $i$ zum Rucksack den 
verbleibenden Platz im Rucksack nicht überschreitet:
Füge den Gegenstand $i$ zum Rucksack hinzu.
Aktualisiere den verbleibenden Platz im Rucksack.
Erhöhe den Gesamtwert um den Wert des Gegenstands $i$.

Schritt 5: \\Gib den Rucksack und den Gesamtwert als Ergebnis 
aus.

Der Greedy-Algorithmus basiert auf der Annahme, dass es 
immer optimal ist, den Gegenstand mit dem höchsten Verhältnis 
von Wert zu Gewicht zu wählen. Diese Annahme kann bei dem Rucksackproblem
keine optimale Lösung Garantieren.

Um dies zu beweisen, betrachten wir ein einfaches Beispiel: 
Gegeben seien drei Gegenstände mit den Werten $v = \{60, 100, 120\}$ 
und den Gewichten $w =\{10, 20, 30\}$. Der Rucksack hat eine Kapazität 
von $W = 50$. Der Greedy-Algorithmus würde den Gegenstand 1 mit 
dem höchsten Verhältnis von Wert zu Gewicht auswählen. Die Optimale 
Lösung lässt Gegenstand 1 aus dem Rucksack und nimmt nur Gegenstand 2 und 3.
Damit ist gezeigt, dass der Greedy-Ansatz nicht für eine optimale Lösung 
garantieren kann.

Die Zeitkomplexität des Greedy-Algorithmus zur Lösung des 
Rucksackproblems ist $O(nlog(n))$, 
wobei $n$ die Anzahl der Gegenstände darstellt. Dabei nimmt das 
sortieren der Liste der Gegenstände die meiste Zeit ein, bzw.\ hat 
die Höchste Zeitkomplexität, weil das Sortieren einer Liste 
keine geringere Zeitkomplexität als $(nlog(n))$ haben kann 
\todo{citation needed}. Der Rest des Greedy"=Algorithmus hat eine 
Laufzeit von $O(n)$.\ \cite[vgl.]{cormen2022introduction}

\section{Dynamische Programmierung}
Die dynamische Programmierung ist eine Methode zur 
Lösung des Rucksackproblems, bei der das Problem in kleinere 
Teilprobleme aufgeteilt wird und die Lösungen der Teilprobleme 
abgespeichert werden, um mögliche Überlappungen zu vermeiden, falls 
diese Teilprobleme erneut berechnet werden müssten.

Um das Rucksackproblem mit dynamischer Programmierung zu 
lösen, müssen zuerst die Teilprobleme betrachtet werden. Sei $n$ die 
Anzahl der verfügbaren Gegenstände und $M$ die Kapazität des 
Rucksacks. Sei $dp$ eine Tabelle, die die maximale 
Gesamtwertsumme für jede Teilmenge der Gegenstände und jede 
mögliche Kapazität des Rucksacks speichert. Die Einträge in 
der Tabelle werden durch $dp[i][j]$ repräsentiert, wobei $i$ den 
Index des aktuellen Gegenstands und $j$ die aktuelle Kapazität 
des Rucksacks darstellt.

Um den Wert in $dp[i][j]$ zu berechnen, betrachtet der Algorithmus 
zwei Möglichkeiten: Entweder der $i$-te Gegenstand wird in den 
Rucksack aufgenommen oder nicht. Wenn der $i$-te Gegenstand 
nicht aufgenommen wird, bleibt der Wert $dp[i][j]$ gleich 
$dp[i-1][j]$. Falls der $i$-te Gegenstand aufgenommen wird, wird 
der Gesamtwert um den Wert des $i$-ten Gegenstands erhöht, und 
die verbleibende Kapazität des Rucksacks wird um das Gewicht 
des $i$-ten Gegenstands reduziert. Der Wert $dp[i][j]$ wird dann 
zu $dp[i-1][j-w[i]] + v[i]$, wobei $w[i]$ das Gewicht und $v[i]$ 
der Wert des $i$-ten Gegenstands ist.

Der Basisfall der dynamischen Programmierung tritt ein, wenn 
entweder $i \le 0$ oder $j = 0$ ist. $i \le 0$ referenziert einen 
Gegenstand ausserhalb der Liste, weshalb $dp[0][j]$ für alle $j$ gleich $0$ ist. 
Der Fall $j = 0$ bedeutet, 
dass der Rucksack keine Kapazität mehr hat und $dp[i][0]$ 
für alle $i$ gleich $0$ ist.

Der rekursive Zusammenhang der dynamischen Programmierung 
kann durch folgende Formel ausgedrückt werden:

\begin{equation}
    \text{dp}[i][j] = \begin{cases}
        \max(\text{dp}[i-1][j], \text{dp}[i-1][j-w[i]] + v[i]), & \text{wenn } j \geq w[i] \\
        \text{dp}[i-1][j], & \text{wenn } j < w[i]
    \end{cases}
\end{equation}


Der Wert in $dp[n][M]$ gibt die maximale Gesamtwertsumme an und 
repräsentiert somit die optimale Lösung des Rucksackproblems.

Die Laufzeit dieses Algorithmus beträgt $O(nM)$, da 
eine Tabelle der Größe $(n+1) × (M+1)$ erstellt wird und 
jeder Eintrag der Tabelle in konstanter Zeit berechnet wird.\ \cite[vgl.]{Martello1987}